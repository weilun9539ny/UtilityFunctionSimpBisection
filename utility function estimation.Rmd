---
title: "Stage 1 Utility Function Estimation"
author: "Wei-Lun, Lin"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# library(magrittr)
library(stringr)
library(tidyverse)

library(rstan)
library(bayesplot)
library(posterior)
library(loo)
```


## Data Reading and Processing

We first get raw data from folders of 2021, 2022 and 2023.
The format of the data in 2021 is a little different from those in 2022 and 2023, 
so we need to separate different cases.

```{r get rawdata}
# get rawdata from foldes of 2021-2023
rawdata <- data.frame()
files.dir <- list.files("./raw data", full.names=T)[-16]
for (i in 1:length(files.dir)) {
  path <- paste0(files.dir[i], "/rawData")
  files <- list.files(path, pattern=".csv", full.names=T)
  for (file in files) {
    if (i < 7) sub.data <- read.csv(file)[, 1:247]
    else sub.data <- read.csv(file)[, 2:248]
    sub <- str_split(file, "/")[[1]][5] %>% substr(1, 10)
    sub.data$sub <- sub
    # print(sub)
    rawdata <- rbind(rawdata, sub.data)
  }
}

head(rawdata[, 1:5])
# write.csv(rawdata, "./rawdata.csv", row.names=F)
```

The extracted raw data contains action time points, values and choices.
To note that, we do not need the time point data, so we remove them next.

```{r remove RT and add subj id}
df <- read.csv("./rawdata.csv")
col.target <- c(
  seq(3, 247, 13), 
  seq(4, 247, 13),
  seq(13, 247, 13)
) %>% 
  sort()
colnames(df)[248] <- "subject"
df <- df[, c(248, col.target)]
df <- df %>% 
  mutate(
    subj_id = row_number()
  ) %>% 
  relocate(subj_id)

head(df[, 1:5])
```

Next, the cells in the dataset are strings of python list.
For example, a possible element could be `"[1000, 800, 600, 400, 200, 100, None, None, 100]"`,
or `"['A', 'B', 'B', 'A', 'A']"`.
Thus, the strings should be convert into vector, and the excess information (the `100, None, None, 100`) should be removed.
Finally, make the data be in long format, which helps further analysis.

I use `fromJSON()` in package `jsonlite` to parse the string of list, and convert elements into vector.
In this way, the data type could be automatically be determined by parser.
And then make the data long.

```{r string parse}
parse_list_string <- function(x) {
  # replace '' and None
  x <- gsub("None", "null", x)
  x <- gsub("'", '"', x)
  # parse the string
  res <- jsonlite::fromJSON(x)
  res <- if(length(res) == 0) NA else res
  return(res)
}

remove_excess_info <- function(vec) {
  vec[1:5]
}

trial_seq <- Vectorize(seq.default, vectorize.args = c("from", "to"))
pos_seq <- trial_seq(from=26:30, to=91:95, by=10) %>% as.vector %>% sort
neg_seq <- trial_seq(from=31:35, to=91:95, by=10) %>% as.vector %>% sort

df_long <- df %>%
  mutate(
    across(-c(subj_id, subject), ~map(.x, parse_list_string)),  # make python list into R vector
    across(ends_with("_list"), ~map(.x, remove_excess_info))  # make value list length be 5
  ) %>% 
  rowwise() %>% 
  transmute(
    subj_id = subj_id,
    subject = subject,
    trial = list(c(1:25, pos_seq, neg_seq)),
    xA1 = list(c(
      rep(2000, 10), rep(0, 10), rep(300, 5), 
      rep(x1pos[[1]], 5), rep(x2pos[[1]], 5), rep(x3pos[[1]], 5), rep(x4pos[[1]], 5), rep(x5pos[[1]], 5), rep(x6pos[[1]], 5), rep(x7pos[[1]], 5),
      rep(300, 35)
    )),
    xA2 = list(c(
      L_list, rep(0, 5), rep(L[[1]], 5), rep(-300, 5), rep(0, 5), 
      rep(-300, 35),
      rep(x1neg[[1]], 5), rep(x2neg[[1]], 5), rep(x3neg[[1]], 5), rep(x4neg[[1]], 5), rep(x5neg[[1]], 5), rep(x6neg[[1]], 5), rep(x7neg[[1]], 5)
    )),
    pA = list(rep(.5, 95)),
    xB1 = list(c(
      rep(0, 5), x1pos_list, x1neg_list, rep(x1pos[[1]], 5), G2_list, 
      x2pos_list, x3pos_list, x4pos_list, x5pos_list, x6pos_list, x7pos_list, x8pos_list,
      rep(G2[[1]], 35)
    )),
    xB2 = list(c(
      rep(0, 5), x1pos_list, x1neg_list, L2_list, rep(x1neg[[1]], 5), 
      rep(L2[[1]], 35),
      x2neg_list, x3neg_list, x4neg_list, x5neg_list, x6neg_list, x7neg_list, x8neg_list
    )),
    pB = list(rep(.5, 95)),
    choice = list(c(
      L_choice_list, x1pos_choice_list, x1neg_choice_list, L2_choice_list, G2_choice_list,
      x2pos_choice_list, x3pos_choice_list, x4pos_choice_list, x5pos_choice_list, x6pos_choice_list, x7pos_choice_list, x8pos_choice_list,
      x2neg_choice_list, x3neg_choice_list, x4neg_choice_list, x5neg_choice_list, x6neg_choice_list, x7neg_choice_list, x8neg_choice_list
    ))
  ) %>% 
  # mutate(trial = list(1:5)) %>% 
  # relocate(trial, .after=subject) %>% 
  unnest(c(trial, starts_with("x"), starts_with("p"), choice)) %>% 
  ungroup() %>% 
  arrange(subj_id, trial)

head(df_long)
```

Finally, we remove observations that subjects did not react.
And change the name of choice "A" and "B" to 1 and 0.

```{r drop na}
dim(df_long)
df_long <- df_long %>% 
  drop_na() %>% 
  mutate(choice = as.numeric(choice == "A"))

dim(df_long)
head(df_long)
# write.csv(df_long, "./subj_trial_data.csv", row.names=F)
```


## Analysis

We ran MCMC to get the cumulative prospect theory (CPT) parameters.

```{r MCMC for CRRA, cache=T}
# read data
df_long <- read.csv("subj_trial_data.csv")

# Setup
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

stan_data <- df_long %>% 
  slice(1:190) %>% 
  list(
    N   = nrow(.),
    S   = length(unique(.$subj_id)),
    subj = .$subj_id,
    y    = as.integer(.$choice),
    xA1  = as.numeric(.$xA1),
    xA2  = as.numeric(.$xA2),
    pA   = as.numeric(.$pA),
    xB1  = as.numeric(.$xB1),
    xB2  = as.numeric(.$xB2),
    pB   = as.numeric(.$pB)
  )

# Fit model
fit <- stan(
  file = "./hierarchical_CPT.stan",
  data = stan_data,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  seed = 2025,
  control = list(adapt_delta = 0.95, max_treedepth = 15)
)
```


```{r}
mcmc_trace(fit, pars = c("alpha[1]", "alpha[2]","beta[1]", "beta[2]","gamma[1]","delta[1]","lambda[1]","phi[1]")) +
  labs(title = "Trace plot")
mcmc_dens_overlay(fit, pars = c("alpha[1]", "alpha[2]","beta[1]", "beta[2]","gamma[1]","delta[1]","lambda[1]","phi[1]")) +
  labs(title = "Posterior Densities")
```



```{r}
print(fit, pars = c("alpha","beta","gamma","delta","lambda","phi"))
```






