---
title: "Stage 1 Simulation"
author: "Wei Lun, Lin"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(R6)
library(tidyverse)
```

## 1. Class 定義

一開始先定義 Player、Game 和 Lotteries 這三個 class。

### 1.1 Player

```{r define-player}
Player <- R6Class(
  "Player",
  private = list(
    # Attributes
    alpha = NA,
    beta = NA,
    lambda = NA,
    phi = NA,
    # Method
    compute_subjective_value = function(x) {  # compute the subjective value of payoff x given its sign
      V <- ifelse(
        x >= 0,
        x ^ private$alpha,  # positive -> x^alpha
        (-(-x) ^ private$beta) * private$lambda  # negative -> gamma * (-(-x)^beta)
      )
      return(V)
    },
    choose = function(lotteries) {  # Choose one of the lotteries depending on the player's utility function
      # Compute net utilities of the 2 lotteries
      V.A <- mean(private$compute_subjective_value(lotteries$A))
      V.B <- mean(private$compute_subjective_value(lotteries$B))
      
      # weird prospect handling
      if (is.na(V.A)) {
        cat("lottery A:", lotteries$A, "\n")
        stop("V.A error!")
      }
      if (is.na(V.B)) {
        cat("lottery B:", lotteries$B, "\n")
        stop("V.B error!")
      }
      
      # Luce choice axiom
      choice.prob <- 1/(1 + exp(private$phi * (V.B - V.A)))
      if (choice.prob > runif(1)) return("A")
      else return("B")
    }
  ),
  public = list(
    initialize = function(alpha, beta, lambda, phi) {
      private$alpha <- alpha
      private$beta <- beta
      private$lambda <- lambda
      private$phi <- phi
    },
    input_choice = function(lotteries) {  # Send player's choice to the game
      choice <- private$choose(lotteries)
      lotteries$update_result(choice)
    }
  )
)
```

`Player` 有 4 個 private attributes：`alpha`、`beta`, `lambda` 和 `phi`。\
有 2 個 private methods：

-   `choose()`：用`compute_prospects()` 算一對彩券分別的 prospects，並根據 choice rule 計算出選A彩券的機率，藉此得到他的選擇
-   `compute_prospects()`：根據效用函數算出該彩券的 prospect

有 1 個 public method：`input_choice()`（把 player 的決策寫在 lotteries 上）。

### 1.2 Lotteries

```{r define-lotteries}
Lotteries <- R6Class(
  "Lotteries",
  private = list(
    # Attributes
    .A = rep(NA, 2),
    .B = rep(NA, 2),
    .result = "",
    # Methods
    new_lotteries = function(game, trial, task, given_values) {  # Set values of private$.A and private$.B
      # Get initial values from the game setting
      G <- game$show_setting()[3]
      L <- game$show_setting()[4]
      g <- game$show_setting()[5]
      l <- game$show_setting()[6]
      
      # Set lotteries' value
      if (trial == 1) {  # L
        private$.A <- c(G, given_values[2])
        private$.B <- c(0, 0)
      } else if (trial == 2) {  # x1pos
        private$.A <- c(G, 0)
        private$.B <- rep(given_values[2], 2)
      } else if (trial == 3) {  # x1neg
        private$.A <- c(0, L)
        private$.B <- rep(given_values[2], 2)
      } else if (trial == 4) {  # L2
        private$.A <- c(0, l)
        private$.B <- c(given_values[1], given_values[2])
      } else if (trial == 5) {  # G2
        private$.A <- c(g, 0)
        private$.B <- c(given_values[2], given_values[1])
      } else if (trial <= 12) {  # xipos, trial: 6-12
        private$.A <- c(given_values[1], l)
        private$.B <- c(given_values[2], given_values[3])
      } else {  # xineg, trial: 13-19
        private$.A <- c(g, given_values[1])
        private$.B <- c(given_values[4], given_values[2])
      }
    }
  ),
  active = list(
    A = function(value) {
      if(missing(value)) {
        return(private$.A)
      }
    },
    B = function(value) {
      if(missing(value)) {
        return(private$.B)
      }
    },
    result = function(value) {
      if(missing(value)) {
        return(private$.result)
      }
    }
  ),
  public = list(
    initialize = function(game, trial, task, given_values) {
      # given_values <- c(x(i-1)pos, xipos_(j-1), L2, G2)
      private$new_lotteries(game, trial, task, given_values)
    },
    update_result = function(choice) {
      private$.result <- choice
    }
  )
)
```

`Lotteries` 有 3 個 private attributes：`A`（彩券 A）、`B`（彩券 B）和 `result`（紀錄 player 的選擇）。同時也用了 active field 來簡化對 A、B 彩券的呼叫。\
有 1 個 private method：`new_lotteries()`，會根據目前的 trial 和 task 來產生相對應的兩張 lotteries。 該 method 在創建物件時被呼叫。\
有 1 個 public method：`update_result()`，讓 player 把答案寫在 lotteries 上。

### 1.3 Game

```{r define-game}
Game <- R6Class("Game",
  private = list(
    # Attributes
    init_values = c("G" = 2000L, "L" = -2000L, "g" = 300L, "l" = -300L, "x1pos" = 1000L),  # G, L, g, l, x1pos
    n_trial = 19L,
    n_task = 5L,
    task_log = NA,  # 19 * 6 matrix, should be initialized
    lotteries_box = NA,  # 95 * 4 matrix, should be initialized
    # Methods
    compute_value = function(choice, cur_task, cur_trial) {  # compute the next x
      # choice <- "A" or "B"
      cur_value <- private$task_log[cur_trial, cur_task]
      step <- abs(private$task_log[cur_trial, 1])  # step size
      delta <- step / (2 ^ cur_task)
      
      if (cur_trial == 1) delta <- - delta  # L changes its value in opposite way
      # update value given choice
      if (choice == "A") {
        cur_value <- cur_value + delta
      } else {
        cur_value <- cur_value - delta
      }
      
      cur_value <- as.integer(round(cur_value / 5) * 5)  # Make cur_value divisible by 5
      return(cur_value)
    }
  ),
  public = list(
    initialize = function() {
      n_trial <- private$n_trial
      n_task <- private$n_task
      # Initialize task_log
      private$task_log <- matrix(NA, nrow = n_trial, ncol = n_task + 1)
      rownames(private$task_log) <- c(
        "L", "x1pos", "x1neg", "L2", "G2", 
        paste0("x", 2:8, "pos"),
        paste0("x", 2:8, "neg")
      )
      private$task_log[1:2, 1] <- private$init_values[c(2, 5)]
      
      # Initialize lotteries_box
      private$lotteries_box <- matrix(NA, nrow=95, ncol=4)  # each row contains lotteries in a trial: c(A1, A2, B1, B2)
      colnames(private$lotteries_box) <- c("A1", "A2", "B1", "B2")
    },
    show_setting = function() {  # Output how many trials and tasks there are in this game
      setting <- c(
        "n.trial" = private$n_trial,
        "n.task" = private$n_task,
        private$init_values
      )
      return(setting)
    },
    generate_lotteries = function(cur_trial, cur_task) {  # Generate a new pair of lotteries.
      # Prepare values that are needed when generating lotteries
      L2 <- private$task_log[4, 6]
      G2 <- private$task_log[5, 6]
      needed_values <- c(rep(NA, 2), L2, G2)  # c(x_{i-1}, x_i_t, L2, G2)
      
      # Find needed_values[1] depending on the demand of current trial
      if (cur_trial %in% 4:5) {  # L2 and G2
        needed_values[1] <- private$task_log[cur_trial - 2, 6]  # The last element of last trial
      } else if (cur_trial == 6) {  # x2pos
        needed_values[1] <- private$task_log[2, 6]  # need x1pos
      } else if (cur_trial == 13) {  # x2neg
        needed_values[1] <- private$task_log[3, 6]  # need x1neg
      } else if (cur_trial >= 7) {  # xipos and xineg, trial:7-12 & 14-19
        needed_values[1] <- private$task_log[cur_trial - 1, 6]  # need x(i-1)pos or x(i-1)neg
      }
      
      # Find needed_values[2] depending on current task
      needed_values[2] <- private$task_log[cur_trial, cur_task]

      # Produce a new pair of lotteries
      new_lotteries <- Lotteries$new(self, cur_trial, cur_task, needed_values)
      return(new_lotteries)
    },
    update_lotteries_box = function(lotteries, cur_trial, cur_task) {
      n.row <- 5 * (cur_trial - 1) + cur_task
      private$lotteries_box[n.row,] <- c(lotteries$A, lotteries$B)
    },
    update_task_log = function(choice, cur_trial, cur_task) {
      # The function takes the choice of players, does the computation, then update the task log.
      # Write the current value
      value <- private$compute_value(choice, cur_task, cur_trial)
      private$task_log[cur_trial, cur_task + 1] <- value
      
      # Update next trial's initial value at the last task
      if (cur_task == 5) {  # Updating values after the final task of this trial
        g <- private$init_values[3]
        l <- private$init_values[4]
        L2 <- private$task_log[4, 6]
        G2 <- private$task_log[5, 6]

        if (cur_trial == 2) {  # x1pos, initialize x1neg[1]
          L <- private$task_log[1, 6]
          private$task_log[3, 1] <- as.integer(5 * round(floor(L / 2) / 5))
        } else if (cur_trial == 3) {  # x1neg, initialize L2[1] & G2[1]
          x1pos <- private$task_log[2, 6]
          x1neg <- private$task_log[3, 6]
          private$task_log[4, 1] <- as.integer(l - x1pos)  # L2
          private$task_log[5, 1] <- as.integer(g - x1neg)  # G2
        } else if (cur_trial == 4) {  # L2, initialize x2pos[1]
          x1pos <- private$task_log[2, 6]
          private$task_log[6, 1] <- as.integer(x1pos + l - L2)  # x2pos[1]
        } else if (cur_trial == 5) {  # G2, initialize x2neg[1]
          x1neg <- private$task_log[3, 6]
          private$task_log[13, 1] <- as.integer(x1neg + g - G2)  # Initialize x2neg
        } else if (cur_trial %in% 6:11) {  # xipos, initialize x(i+1)pos
          xipos <- private$task_log[cur_trial, 6]
          private$task_log[cur_trial + 1, 1] <- as.integer(xipos + l - L2)  # x(i+1)pos[1]
        } else if (cur_trial %in% 13:18) {  # xineg, initialize x(i+1)neg
          xineg <- private$task_log[cur_trial, 6]
          private$task_log[cur_trial + 1, 1] <- as.integer(xineg + g - G2)  # x(i+1)neg[1]
        }
      }
    },
    output_exp_result = function() {
      rows <- c(2, 6:12, 3, 13:19)
      result <- private$task_log[rows, 6]
      names(result) <- c(paste0("x", 1:8, "pos"), paste0("x", 1:8, "neg"))
      res.df <- as.data.frame(t(result))
      return(res.df)
    },
    show_task_log = function() private$task_log,
    show_lotteries_box = function() private$lotteries_box
  )
)
```

`Game` 有 5 個 private attributes：

-   `init_value`：$G$、$L$、$g$、$l$
-   `n_trial`
-   `n_task`
-   `task_log`：$19 \times 6$ 的 matrix，紀錄實驗中的所有 $x_i^+, x_i^-, \text{for} i=1, ..., 8$
-   `lotteries_box`：$19\times 5$ 的 matrix，紀錄實驗中的所有 lotteries

有 1 個 private method：`compute_value()`，根據 player 的選擇來更新下一張 lotteries 所需要的數值。\
有 7 個 public method：

-   `show_setting()`：輸出 `n_trial`、`n_task` 和 `init_value`
-   `generate_lotteries()`：根據目前的 trial 和 task 產生相對應的 lottery
-   `update_lotteries_box()`：把 lotteries 和 player 的選擇，都一起儲存下來
-   `update_task_log()`：player 選擇之後，計算下一張 lottery 會用到的值，並且紀錄下來
-   `output_exp_result()`：實驗結束後，把 $x^+_1$ 到 $x^+_8$、$x^-_1$ 到 $x^-_8$ 儲存起來，並以 1d vector 的形式輸出
-   `show_task_log()`：輸出 `task_log`，輸出格式是 list of vector
-   `show_lotteries_box()`：輸出 `lotteries_box`，輸出格式是 `dim = 2` 的 list

## 2. 實驗架構(Define `experiment()`)

根據 3 個 class 之間的互動，implement sequence diagram。

```{r define-experiment}
experiment = function(params) {  # Given player's attribute
  # Initialize the player given parameters and the game
  player <- Player$new(params[1], params[2], params[3], params[4])  # params <- c(alpha, beta, lambda, phi)
  game <- Game$new()

  # Start the experiment
  for (trial in 1:game$show_setting()[1]) {
    for (task in 1:game$show_setting()[2]) {
      # cat("Current progress: Trial", trial, ", Task", task, "\n")
      cur_lotteries <- game$generate_lotteries(trial, task)
      player$input_choice(cur_lotteries)
      game$update_lotteries_box(cur_lotteries, trial, task)
      game$update_task_log(cur_lotteries$result, trial, task)
    }
  }

  # Finish the experiment
  names(params) <- c("alpha", "beta", "lambda", "phi")
  res <- list(
    "pars" = params,
    "points" = game$output_exp_result(),
    "log" = game$show_task_log(),
    "material" = game$show_lotteries_box()
  )
  return(res)
}
```

```{r test-experiment}
experiment(c(.88, .88, 1, .03))
```


## 3. 設定參數空間

$\alpha\in[0, 2], \beta \in [0, 2], \phi \in \{0.367, 0.0367, 0.00367\}.$

```{r parameter-space}
dat <- crossing(
  alpha = seq(.1, 2, .03),
  beta = seq(.1, 2, .03), 
  lambda = 1,
  phi = c(.367, .0367, .00367)
) %>% 
  mutate(subj_id = row_number()) %>% 
  relocate(subj_id) %>% 
  as.data.frame()

# dat %>% write.csv("../01-data/generated_data/subject_alpha-beta-phi.csv", row.names=F)
# dat <- read.csv("../01-data/generated_data/subject_alpha-beta-phi.csv")
dat %>% head()
```


## 4. 模擬實驗

使用生成的受試者資料進行模擬實驗。

```{r simulation, cache=T}
# initialize a df to store experiment results for all the subjects
res.df <- data.frame()
log.path <- "./../01-data/generated_data/experiment-log/log_"
material.path <- "./../01-data/generated_data/experiment-material/material_"

for (subj in dat$subj_id) {
  pars <- dat[subj, 2:5] %>% 
    unlist %>% 
    unname
  res <- experiment(pars)
  
  # store the result
  res.df <- rbind(res.df, res$points)
  file.name <- paste0( 
    "subj-", subj, 
    "_alpha-", res$pars[[1]], 
    "_beta-", res$pars[[2]], 
    "_phi-", res$pars[[4]], 
    ".csv"
  )
  res$log %>% write.csv(paste0(log.path, file.name), row.names=T)
  res$material %>% write.csv(paste0(material.path, file.name), row.names=F)
}

# res.df %>% write.csv("../01-data/generated_data/simulation-result.csv", row.names=F)
res.df %>% str()
```




